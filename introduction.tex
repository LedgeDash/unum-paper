\section{Introduction}\label{sec:intro}

\majoredits{Serverless computing offers a simple but powerful abstraction with
two essential components: a stateless compute engine (Functions as a Service,
or FaaS) and a scalable, multi-tenant data store~\cite{berkeley}. Developers
build applications using stateless, event-driven ``functions'' which persist
states in shared data stores. This abstraction allows users to leverage
scalable datacenter resources with fine-grained per-invocation billing
and frees them from server administration.}

While serverless platforms originally targeted simple applications with one or
a few functions, this paradigm has increasingly proven useful for more
complex applications composed of many functions with rich and often stateful
interaction patterns~\cite{excamera, pywren, gg-atc, beldi, boki}.
Unfortunately, building such applications using the basic FaaS is
challenging. \majoredits{Event-driven execution makes depending on the
results of multiple previous functions \majoredits{and therefore fan-in
patterns} difficult. At-least-once execution guarantee that is typical for
FaaS functions complicates end-to-end application correctness as
non-deterministic functions may pass inconsistent results downstream.}
Finally, the lack of higher-level programming interfaces for expressing inter-function
patterns hinders application development.

\majoredits{\secondedits{Standalone orchestrators are recently introduced into
 serverless infrastructure to support such complex applications (\S\ref
 {sec:bg:orchestrator}).} Cloud providers commonly offer serverless
 orchestrators as a service~\cite{aws-step-functions, google-cloud-composer,
 google-workflows, durable-functions}, though users may build custom
 orchestrators~\cite{temporal, gg-atc, excamera} and deploy them in separate
 VMs or containers alongside their functions.\secondedits
 {Orchestrators provide higher-level programming interfaces, support complex
 interactions and ensure exactly-once execution.}}

\majoredits{Though often internally distributed, standalone orchestrators
 operate as \emph{logically centralized} controllers. Developers provide a
 description of an execution graph---nodes in the graph represent FaaS
 functions and edges represent invocations of a function with the output of
 one or more functions---and the orchestrator drives the execution of this
 graph by invoking functions, receiving function results and storing
 application states (e.g., outstanding invocations and function results)
 centrally.}

Centralization simplifies supporting \majoredits
{stateful} interactions---e.g., an orchestrator can support fan-in patterns
by simply waiting for all branches to complete before invoking an aggregation
function. Similarly, a centralized orchestrator can ensure that applications
appear to execute exactly-once by choosing a single result from multiple
executions for each function invocation.

\majoredits{However, standalone orchestrators have important drawbacks for
 both serverless providers and serverless users. As an additional service
 that is critical to application performance and correctness, a standalone
 orchestrator is expensive to \secondedits{host and use}. User-deployed
 orchestrators risk under-utilization and do not benefit from
 serverless' \secondedits{pay-for-what-you-use} billing and freedom from
 server management. Provider-hosted orchestrators are multi-tenant and can
 thus multiplex over many users to improve resource utilization and amortize
 the cost. However, they still incur the expenses of dedicated hardware
 resources and on-call engineering teams.

Furthermore, standalone orchestrators preclude users from making
application-specific trade-offs and optimizations. While the interface and
implementation of an orchestrator might efficiently support the needs of many
applications, it cannot meet all applications' needs, resulting in a
compromise familiar from operating systems~\cite{exokernel,spin},
networks~\cite{active-networks,sdn}, and storage
systems~\cite{comet,splinter}.}

\majoredits{For example, applications that need orchestration patterns not
 supported by the \secondedits{provider-hosted} orchestrator have to either
 compromise performance by using less-efficient patterns or first repeat the
 hard work of building, deploying and managing their own custom
 orchestrator. \secondedits{A video processing application that encodes video
 chunks and aggregates results of adjacent branches in parallel have to
 compromise performance if the orchestrator only supports aggregating results
 of all branches (\S\ref{sec:eval:excamera}).} Similarly, \secondedits
 {deterministic applications, such as an image resize application or a IoT
 data processing pipeline for aggregating sensor readings, can tolerate
 duplicate executions without weakening correctness, but otherwise cannot
 reap performance benefits if the orchestrator only supports strong
 exactly-once execution.}}

\majoredits{In this paper, we show that additional standalone orchestrators
 for serverless applications are unnecessary. Furthermore, we argue that
 decentralized, application-level orchestration is better for both serverless
 providers and serverless users. \secondedits{It is better for applications
 as it affords them more flexibility to implement custom patterns as needed
 and apply application-specific optimizations. It is better for cloud
 providers as it reduces costs by obviating the need to host and maintain an
 additional complex service, which can in turn lower users' costs of
 running applications}. Moreover, as cloud providers improve the performance
 of essential serverless components, application-level orchestration built on
 top of those services benefit automatically.}

To support these arguments, we present \name{}, a system for
decentralized\majoredits{, application-level} serverless workflow
orchestration (\S\ref{sec:design}). \name{} provides orchestration as a
library that runs \emph{in-situ} with user-defined FaaS functions, rather than
as a \majoredits{standalone} service. The library relies on a minimal set of
existing serverless APIs---function invocation and a few basic datastore
operations---that are common across cloud platforms. \name{} introduces an
intermediate representation (IR) language to express execution graphs using
only node-local information while supporting front-end compilers that can
transform high-level workflow descriptions into the IR.

\majoredits{A key challenge in \name{} is to support complex stateful
orchestration patterns and strong execution guarantees, in a
\emph{decentralized} manner. Our insight is that, scalable and strongly
consistent data stores, already an essential building block of serverless
applications, address the hardest challenge of orchestration: coordination.
Using such data stores, we show that an application-level library running
in-situ with user functions can orchestrate complex execution graphs
efficiently with strong execution guarantees.}

\majoredits{At a high level, \name{} relies on the FaaS scheduler to run each
function invocation \emph{at least} once and consistent data store operations
to coordinate interactions and de-duplicate extra executions of the same
invocation. \name{} uses checkpoints to commit to exactly one result for a
function invocation and ensures workflow correctness despite duplicate
executions of non-deterministic functions. \name{} fan-ins use objects in a
consistent datastore as a coordination point for aggregating branches. Both
require generating globally unique names for nodes and edges in the execution
graph \emph{locally} (using only information available at each node) as well
as cleaning up intermediate data store objects in a timely manner.}

Our implementation of \name{} (\S\ref{sec:impl}) includes a compiler for AWS
Step Functions' description language, enabling \name{} to run arbitrary Step
Function workflows. We show that Step Function workflows compiled to \name{}
execute with the same execution guarantees as running natively using the Step
Functions orchestrator.

\secondedits{To the best of our knowledge, \name{} is the first system that
 supports complex serverless applications with exactly-once execution
 guarantees without requiring additional services or changes to the FaaS
 abstraction (e.g., making functions stateful and addressable).}Moreover,
 while performance and cost are difficult to compare objectively with
 existing black-box production orchestrators---both are influenced by
 deployment and pricing decisions that may not reflect the underlying
 efficiency or cost of the system---\name{} performs well in practice(\S\ref
 {sec:eval}). We find that a representative set of applications run faster
 and cost significantly less with \name{} than Step Functions (Table~\ref
 {table:macro}). We also demonstrate that \name{}'s IR allows hand-tuned
 applications to run faster by using application-specific optimizations and
 supporting a richer set of interaction patterns.
