\section{Implementation}\label{sec:impl}

\subsection{AWS Lambda}

\begin{enumerate}
  \item \textbf{Asynchronous invocation} supported natively with via the \texttt{Invoke} API and \texttt{InvocationType} ``Event''.
\end{enumerate}

\subsubsection{DynamoDB}

\begin{enumerate}
  \item \textbf{Create and write to object with value} Uses \texttt{put\_item} with the conditional flag \texttt{attribute\_not\_exists} for the key.
  \item Create Set
  \item Add to set
  \item Get set size
\end{enumerate}

\subsubsection{S3}

\begin{enumerate}
  \item Create and write to object with value
  \item Create Set
  \item Add to set
  \item Get set size
\end{enumerate}

\subsection{Google Cloud Functions}

\begin{enumerate}
  \item \textbf{Asynchronous invocation} enqueue the event in a function-specific Pub/Sub queue. On deployment, the function is set up as a subscriber to the queue to run for each event.
\end{enumerate}

\subsubsection{Firestore}

\begin{enumerate}
  \item \textbf{Create and write to object with value} A firestore document \texttt{create} operation writes a value to a key only if the key doesn't exist
  \item Create Set
  \item Add to set
  \item Get set size
\end{enumerate}


We implement a prototype of \name{} that runs Python functions on AWS Lambda
with DynamoDB as the intermediary data store. The frontend compiler
supports workflows written as AWS Step Functions state machines. The compiler
is written in Python with 1,277 lines of code.
% \dhl{How the frontend compiler
%transforms a Step Functions state machine to a directed graph and then
%transforms it to the \name{} IR is beyond the scope of this paper}. 
The runtime are written in Python with 2,957 lines of code. We also integrate
our toolchain with AWS SAM to build and deploy \name{} workflows as Amazon
CloudFormation stacks, which automates the development process. Developers can
list all resources in a workflow, including the intermediary data store, and
deploy them with one simple command.

The runtime uses the \texttt{boto3} library to interact with AWS services.
Lambda functions are invoked asynchronously (\texttt{InvocationType='Event'})
with the \texttt{invoke()} API. Checkpointing to DynamoDB is a
\texttt{PutItem} operation with a condition that the item does not already
exist (\texttt{ConditionExpression=attribute\_not\_exists()}). Check
checkpoint existence is a consistent read via \texttt{GetItem} operation. For
fan-in functions, reading input from DynamoDB uses the \texttt{BatchGetItem}
operation with consistent reads.
\name{} by default uses the on-demand capacity mode when creating DynamoDB
tables where applications are charged by the amount of read and write it
performs instead of a fixed hourly rate.

One important implementation detail is that synchronization among fan-in
functions must be idempotent because functions can crash and retries might
execute synchronization logic again. Therefore, many common synchronization
data structures, such as an atomic counter where parallel functions increments
the counter to signal completion, cannot be used. Instead, \name{} uses an
array of booleans initialized to all false. The egress runtime on each fan-in
function sets the value to true at the array index that is equal to the node's
branch index.
